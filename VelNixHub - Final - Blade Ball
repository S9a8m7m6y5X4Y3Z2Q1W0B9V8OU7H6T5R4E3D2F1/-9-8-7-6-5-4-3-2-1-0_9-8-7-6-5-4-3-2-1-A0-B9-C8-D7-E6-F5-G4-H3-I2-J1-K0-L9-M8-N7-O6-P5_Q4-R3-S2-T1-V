local nurysium_module = {}
function nurysium_module.isAlive(Entity)
    if not Entity.Character then
        return false
    end

    local aliveFolder = workspace:FindFirstChild("Alive")
    if aliveFolder then
        local aliveEntity = aliveFolder:FindFirstChild(Entity.Name)
        return aliveEntity and aliveEntity:FindFirstChild("Humanoid") and aliveEntity.Humanoid.Health > 0
    end

    return false
end

function nurysium_module.getBall()
    local ballsFolder = workspace:WaitForChild("Balls")
    if not ballsFolder then
        return nil
    end

    for _, ball in ipairs(ballsFolder:GetChildren()) do
        if ball:IsA("BasePart") and ball:GetAttribute("realBall") then
            return ball
        end
    end

    return nil
end

local getTrainingBall = function()
    local trainingBallsFolder = workspace:WaitForChild("TrainingBalls")
    for _, ball in ipairs(trainingBallsFolder:GetChildren()) do
        if ball:IsA("BasePart") and ball:GetAttribute("realBall") then
            return ball
        end
    end
end

local Nurysium_Util = {
    getBall = function()
        return nurysium_module.getBall()
    end,
    getTrainingBall = function()
        return getTrainingBall()
    end
}

local Stats = game:GetService("Stats")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local AdService = game:GetService("AdService")
local SocialService = game:GetService("SocialService")

local local_player = Players.LocalPlayer
local camera = workspace.CurrentCamera

local originalParryRemote
local originalResolveParryRemote 

local nurysium_Data = nil
local hit_Sound = nil
local closest_Entity = nil

local aura_Enabled = false
local auto_curve = false
local auto_spam = false
local training_mode = false
local anti_curve_spam_Enabled = false
local visualize_Enabled = false
local hit_sound_Enabled = false
local hit_effect_Enabled = false
local night_mode_Enabled = false
local trail_Enabled = false
local self_effect_Enabled = false
local kill_effect_Enabled = false
local shaders_effect_Enabled = false
local ai_Enabled = false
local spectate_Enabled = false
local target_closest_player = true

local Services = {game:GetService("AdService"),game:GetService("SocialService")}

function SwordCrateManual()
	game:GetService("ReplicatedStorage").Remote.RemoteFunction:InvokeServer("PromptPurchaseCrate",workspace.Spawn.Crates.NormalSwordCrate)
end

function ExplosionCrateManual()
	game:GetService("ReplicatedStorage").Remote.RemoteFunction:InvokeServer("PromptPurchaseCrate",workspace.Spawn.Crates.NormalExplosionCrate)
end

function SwordCrateAuto()
	while _G.AutoSword do
		game:GetService("ReplicatedStorage").Remote.RemoteFunction:InvokeServer("PromptPurchaseCrate",workspace.Spawn.Crates.NormalSwordCrate)
		task.wait(1)
	end
end

function ExplosionCrateAuto()
	while _G.AutoBoom do
		game:GetService("ReplicatedStorage").Remote.RemoteFunction:InvokeServer("PromptPurchaseCrate",workspace.Spawn.Crates.NormalExplosionCrate)
		task.wait(1)
	end
end

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua", true))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua", true))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua", true))()

Fluent:Notify({
    Title = [[ [ VelNix Hub - Loaded! ]
 VelNix V1.2.9: Public Loaded.]],
    Content = [[Feel Free to Showcase.]],
    Duration = 5,
    Type = "Info"
})

local executorName = "Unknown Executor - If You See This Your Executor is Gay"
if identifyexecutor then
    executorName = identifyexecutor()
end

local Window = Fluent:CreateWindow({
    Title = "VelNix Hub V1.2.9",
    SubTitle = "By [Orealated] - " .. executorName,
    TabWidth = 180,
    Size = UDim2.fromOffset(500, 250),
    Acrylic = false,
    Theme = "Darker",
    MinimizeKey = Enum.KeyCode.LeftControl -- Used when there's no MinimizeKeybind
})

local Tabs = {
	Main = Window:AddTab({ Title = "Main", Icon = "shield" }),
	Misc = Window:AddTab({ Title = "Misc", Icon = "component" }),
	Loggs = Window:AddTab({ Title = "Changelogs", Icon = "bell-plus" }),
}

local Options = Fluent.Options
function initializate(dataFolder_name)
	nurysium_Data = Instance.new("Folder", game:GetService("CoreGui"))
	nurysium_Data.Name = dataFolder_name
	hit_Sound = Instance.new("Sound", nurysium_Data)
	hit_Sound.SoundId = "rbxassetid://8632670510"
	hit_Sound.Volume = 5
end

local function get_closest_entity(Object)
	task.spawn(function()
		local closest
		local max_distance = math.huge
		for index, entity in workspace.Alive:GetChildren() do
			if entity.Name ~= Players.LocalPlayer.Name then
				local distance = (Object.Position - entity.HumanoidRootPart.Position).Magnitude
				if distance < max_distance then
					closest_Entity = entity
					max_distance = distance
				end
			end
		end
		return closest_Entity
	end)
end

function resolve_parry_Remote()
	for _, value in Services do
		local temp_remote = value:FindFirstChildOfClass("RemoteEvent")
		if temp_remote and temp_remote.Name:find("\n") then
			originalParryRemote = temp_remote -- Store the original reference here
			break  -- Exit the loop once you find the RemoteEvent
		end
	end
end

resolve_parry_Remote()

local aura_table = {
	canParry = true,
	is_Spamming = false,
	parry_Range = 0,
	spam_Range = 0,  
	hit_Count = 0,
	hit_Time = tick(),
	ball_Warping = tick(),
	is_ball_Warping = false,
	last_target = nil,
}

ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(function()
	if hit_sound_Enabled then
		hit_Sound:Play()
	end
	if hit_effect_Enabled then
		local hit_effect = game:GetObjects("rbxassetid://17407244385")[1]
		hit_effect.Parent = Nurysium_Util.getBall()
		hit_effect:Emit(3)
		task.delay(5, function()
			hit_effect:Destroy()
		end)
	end
end)

local workspace_Balls = workspace:WaitForChild("Balls")
local remotes_ParrySuccessAll = ReplicatedStorage.Remotes:WaitForChild("ParrySuccessAll")

local function resetAuraTable()
    aura_table.hit_Count = 0
    aura_table.is_ball_Warping = false
    aura_table.is_Spamming = false
    aura_table.can_parry = true
    aura_table.last_target = nil
end

workspace_Balls.ChildRemoved:Connect(resetAuraTable)
remotes_ParrySuccessAll.OnClientEvent:Connect(function()
    aura_table.hit_Count = math.max(0, aura_table.hit_Count + 1)
    task.delay(0.185, function()
        aura_table.hit_Count = math.max(0, aura_table.hit_Count - 1)
    end)
end)

task.spawn(function()
    local heartbeatConnection = RunService.Heartbeat:Connect(function()
        if not auto_spam then
            auto_spam = false
            pcall(function()
                heartbeatConnection:Disconnect()
            end)
        end
    end)
end)

local Mainy = Tabs.Main:AddSection("The Main Features")
Mainy:AddParagraph({
    Title = "[ VelNix: Recommend Configs ]",
    Content = "I Recommend to Turn on:\nAuto Parry + Auto Spam and Disable Your Ball Curve\nOptional: Fps Booster, Visualizer and Auto Curve"
})
local Toggle = Mainy:AddToggle("PingBasedParry", {Title = "Auto Parry + Auto Spam", Description = "May Work With High Amount of Ping Like 200-300.", Default = true })
Toggle:OnChanged(function(toggled)
    aura_Enabled = toggled
    auto_spam = toggled
end)
local Toggle = Mainy:AddToggle("TrainingBalls", {Title = "Auto Parry: Training Area Support", Description = "Turn Off if You're Not in The Training Area, as it May Effect Parrying The Ball.", Default = false })
Toggle:OnChanged(function(toggled)
	training_mode = Options.TrainingBalls.Value
end)
local Toggle = Mainy:AddToggle("AutoCurve", {Title = "Auto Parry: Auto Curve", Description = "Curves The Ball Automatically Which Can Confuse Opponents.", Default = false })
Toggle:OnChanged(function(toggled)
	auto_curve = Options.AutoCurve.Value
end)
local Others = Tabs.Main:AddSection("Other Features")
local Toggle = Others:AddToggle("Visualize", {Title = "Visualizer", Description = "Visualize The Auto Parry.", Default = false })
Toggle:OnChanged(function(toggled)
	visualize_Enabled = Options.Visualize.Value
end)
local function getPingStatus(ping)
    if ping <= 50 then
        return "Excellent Ping"
    elseif ping <= 100 then
        return "Good Ping"
    elseif ping <= 150 then
        return "Decent Ping"
    elseif ping <= 200 then
        return "Moderate Ping"
    elseif ping <= 250 then
        return "High Ping"
    else
        return "Very High Ping"
    end
end

Others:AddButton({
    Title = "Check Ping",
    Description = "Checks Your Ping",
    Callback = function()
        local ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue()
        local pingStatus = getPingStatus(ping)

        Fluent:Notify({
            Title = "[ VelNix Hub - Ping Checker ]",
            Content = "Your Current Ping is: " .. tostring(ping) .. " ms [" .. pingStatus .. "]",
            Duration = 5,
            Type = "Info"
        })
    end
})
local Toggle = Others:AddToggle("AnticurveSpam", {Title = "Disable Your Ball Curve", Description = "Disables Your Curving, Can Make Parrying Better", Default = false })
Toggle:OnChanged(function(toggled)
    anti_curve_spam_Enabled = toggled
    local self = Nurysium_Util.getBall()
    if self then
        if anti_curve_spam_Enabled then
            self.AssemblyLinearVelocity = Vector3.new(self.AssemblyLinearVelocity.X, self.AssemblyLinearVelocity.Y, 0)
        else
            self.AssemblyLinearVelocity = self.AssemblyLinearVelocity
        end
    end
end)
local Money = Tabs.Main:AddSection("Crates Opener")
Money:AddButton({
	Title = "Open Sword Crate",
	Description = "Opens One Sword Crate | Costs [80]",
	Callback = function()
		SwordCrateManual()
	end
})
Money:AddToggle("AutoSwordCrate", {
    Title = "Auto Open Sword Crate",
    Description = "Automatically Opens Sword Crates | Costs [80]",
    Default = false
}):OnChanged(function(toggled)
    autoSwordCrate = toggled
    if autoSwordCrate then
        task.spawn(function()
            while autoSwordCrate do
                SwordCrateManual()
                task.wait(1.2)
            end
        end)
    end
end)
Money:AddButton({
	Title = "Open Explosion Crate",
	Description = "Opens One Explosion Crate | Costs [80]",
	Callback = function()
		ExplosionCrateManual()
	end
})
Money:AddToggle("AutoExplosionCrate", {
    Title = "Auto Open Explosion Crate",
    Description = "Automatically opens Explosion Crates",
    Default = false
}):OnChanged(function(toggled)
    autoExplosionCrate = toggled
    if autoExplosionCrate then
        task.spawn(function()
            while autoExplosionCrate do
                ExplosionCrateManual()
                task.wait(1.2)
            end
        end)
    end
end)
local Misc = Tabs.Misc:AddSection("Miscellaneous")
local Toggle = Misc:AddToggle("Nightmode", {Title = "Night Mode", Description = "Sets The Sky to Night Mode.", Default = false })
Toggle:OnChanged(function(toggled)
	night_mode_Enabled = Options.Nightmode.Value
end)
local Toggle = Misc:AddToggle("Trail", {Title = "Character Trail", Description = "Gives Your Character a Trail.", Default = false })
Toggle:OnChanged(function(toggled)
	trail_Enabled = Options.Trail.Value
end)
local Toggle = Misc:AddToggle("SpectateBall", {Title = "Spectate Ball", Description = "Manipulate Your Camera to Spectate The Ball.", Default = false })
Toggle:OnChanged(function(toggled)
	spectate_Enabled = Options.SpectateBall.Value
end)
Misc:AddButton({
	Title = "Fps Booster",
	Description = "Use This to Boost Your Fps.",
	Callback = function()
		_G.Settings = {
    Players = {
        ["Ignore Me"] = true, -- Ignore your Character
        ["Ignore Others"] = true -- Ignore other Characters
    },
    Meshes = {
        Destroy = true, -- Destroy Meshes
        LowDetail = true -- Low detail meshes (NOT SURE IT DOES ANYTHING)
    },
    Images = {
        Invisible = true, -- Invisible Images
        LowDetail = true, -- Low detail images (NOT SURE IT DOES ANYTHING)
        Destroy = true, -- Destroy Images
    },
    ["No Particles"] = true, -- Disables all ParticleEmitter, Trail, Smoke, Fire and Sparkles
    ["No Camera Effects"] = true, -- Disables all PostEffect's (Camera/Lighting Effects)
    ["No Explosions"] = true, -- Makes Explosion's invisible
    ["No Clothes"] = true, -- Removes Clothing from the game
    ["Low Water Graphics"] = true, -- Removes Water Quality
    ["No Shadows"] = true, -- Remove Shadows
    ["Low Rendering"] = true, -- Lower Rendering
    ["Low Quality Parts"] = true -- Lower quality parts
}
loadstring(game:HttpGet("https://raw.githubusercontent.com/Orealated/VelNix/main/VelNixHub%20RipsFps%20Modified.txt", true))();
	end
})
local Logs = Tabs.Loggs:AddSection("Changelogs")
Logs:AddParagraph({
    Title = "[ VelNix: V1.1.2 ]",
    Content = [[ [+] Fixed Most Bugs Where it Accidentally Parries The Ball Even Tho Your Not The One Being Targeted.
 [+] Improved Auto Spam And Auto Parry.]]
})
Logs:AddParagraph({
    Title = "[ VelNix: V1.2.9 ]",
    Content = [[ [+] Fully Fixed a Bug Where it Accidentally Parries The Ball Even Tho Your Not The One Being Targeted.
 [+] Improved Long Range Auto Parry.
 Developer Note: Auto Rapture Soon]]
})

local function clamp(value, min, max)
    return math.max(min, math.min(max, value))
end

task.spawn(function()
    local self = Nurysium_Util.getBall()
    if self then
        local Visualize = Instance.new("Part", workspace)
        Visualize.Color = Color3.fromRGB(128, 128, 128)
        Visualize.Material = Enum.Material.ForceField
        Visualize.Transparency = 0.5
        Visualize.Anchored = true
        Visualize.CanCollide = false
        Visualize.CastShadow = false
        Visualize.Shape = Enum.PartType.Ball
        Visualize.Size = Vector3.new(1, 1, 1)

        local Highlight = Instance.new("Highlight")
        Highlight.Parent = Visualize
        Highlight.Enabled = true
        Highlight.FillTransparency = 0
        Highlight.OutlineColor = Color3.fromRGB(255, 255, 255)

        RunService.RenderStepped:Connect(function()
            if visualize_Enabled and self and local_player then
                local ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 10
                local ball_Position = self.Position
                local player_Position = local_player.Character.PrimaryPart.Position
                local ball_Velocity = self:FindFirstChild("zoomies") and self.zoomies.VectorVelocity or self.AssemblyLinearVelocity
                local ball_Direction = (local_player.Character.PrimaryPart.Position - ball_Position).Unit
                local ball_Distance = (local_player.Character.PrimaryPart.Position - ball_Position).Magnitude
                local ball_Dot = ball_Direction:Dot(ball_Velocity.Unit)
                local ball_Speed = ball_Velocity.Magnitude

                local speedFactor = 3.25 - (ping / 150)
                local speedFactorPingBased = 5.5 - (ping / 100)
                local parry_Range = math.max(math.max(ping, 3.5) + ball_Speed / speedFactor, speedFactorPingBased)

                local visualizer_Size = Vector3.new(parry_Range * 2, parry_Range * 2, parry_Range * 2)

                Visualize.Transparency = 0
                Visualize.Material = Enum.Material.ForceField
                Visualize.Size = visualizer_Size
                Visualize.CFrame = CFrame.new(player_Position)
            else
                Visualize.Material = Enum.Material.ForceField
                Visualize.Transparency = 1
            end
        end)
    end
end)

task.defer(function()
    game:GetService("RunService").Heartbeat:Connect(function()
        if not local_player or not local_player.Character then
            return
        end

        if trail_Enabled then
            local trail = game:GetObjects("rbxassetid://17483658369")[1]
            trail.Name = "nurysium_fx"

            if local_player.Character.PrimaryPart:FindFirstChild("nurysium_fx") then
                return
            end

            local Attachment0 = Instance.new("Attachment", local_player.Character.PrimaryPart)
            local Attachment1 = Instance.new("Attachment", local_player.Character.PrimaryPart)
            Attachment0.Position = Vector3.new(0, -2.411, 0)
            Attachment1.Position = Vector3.new(0, 2.504, 0)
            trail.Parent = local_player.Character.PrimaryPart
            trail.Attachment0 = Attachment0
            trail.Attachment1 = Attachment1
        else
            if local_player.Character.PrimaryPart:FindFirstChild("nurysium_fx") then
                local_player.Character.PrimaryPart["nurysium_fx"]:Destroy()
            end
        end
    end)
end)

task.defer(function()
	RunService.RenderStepped:Connect(function()
		if spectate_Enabled then
			local self = Nurysium_Util.getBall()
			if not self then
				return
			end
			workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(CFrame.new(workspace.CurrentCamera.CFrame.Position, self.Position), 1.5)
		end
	end)
end)

task.defer(function()
	while task.wait(1.2) do
		if night_mode_Enabled then
			game:GetService("TweenService"):Create(game:GetService("Lighting"), TweenInfo.new(3), {ClockTime = 3.9}):Play()
		else
			game:GetService("TweenService"):Create(game:GetService("Lighting"), TweenInfo.new(3), {ClockTime = 13.5}):Play()
		end
	end
end)

local function Parry(targetPosition)
    task.spawn(function()
        local cameraPosition = camera.CFrame.Position
        local cameraLookVector = camera.CFrame.LookVector

        if auto_curve then
            local randomPosition = Vector3.new(
                math.random(-1000, 1000),
                math.random(0, 1000),
                math.random(100, 1000)
            )
            originalParryRemote:FireServer(0, CFrame.new(cameraPosition, randomPosition), {[closest_Entity.Name] = targetPosition}, {targetPosition.X, targetPosition.Y}, false)
        else
            originalParryRemote:FireServer(0, CFrame.new(cameraPosition, cameraPosition + cameraLookVector), {[closest_Entity.Name] = targetPosition}, {targetPosition.X, targetPosition.Y}, false)
        end
    end)
end

task.spawn(function()
    RunService.Heartbeat:Connect(function()
        aura_table.Takentime = tick() - aura_table.hit_Time
    end)
end)

local lastSpamTime = 0
local spamInterval = task.wait(0)

local function autoSpam()
    if not auto_spam or not workspace.Alive:FindFirstChild(local_player.Name) or training_mode then
        aura_table.hit_Count = 0
        aura_table.is_Spamming = false
        aura_table.last_target = nil
        return
    end

    if closest_Entity and workspace.Alive:FindFirstChild(closest_Entity.Name) then
        if aura_table.is_Spamming and aura_table.hit_Count >= 1 then
            local playerPosition = local_player.Character.PrimaryPart.Position
            local targetPosition = closest_Entity.HumanoidRootPart.Position
            local distance = (playerPosition - targetPosition).Magnitude

            local ball = Nurysium_Util.getBall()
            if distance <= aura_table.spam_Range and ball and ball:GetAttribute('target') == local_player.Name then
                local currentTime = tick()
                if currentTime - lastSpamTime >= spamInterval then
                    lastSpamTime = currentTime
                    task.spawn(function()
                        Parry(targetPosition)
                    end)
                else
                    aura_table.is_Spamming = false
                end
            end
        end
    end
end

task.spawn(function()
    while true do
        autoSpam()
        task.wait(0)
    end
end)

task.spawn(function()
    while true do
        if not auto_spam or not workspace.Alive:FindFirstChild(local_player.Name) or training_mode then
            aura_table.hit_Count = 0
            aura_table.is_Spamming = false
            aura_table.last_target = nil
        end
        task.wait(0)
    end
end)

task.spawn(function()
    while true do
        if closest_Entity and workspace.Alive:FindFirstChild(closest_Entity.Name) then
            if aura_table.is_Spamming and aura_table.hit_Count >= 1 then
                local playerPosition = local_player.Character.PrimaryPart.Position
                local targetPosition = closest_Entity.HumanoidRootPart.Position
                local distance = (playerPosition - targetPosition).Magnitude

                if distance <= aura_table.spam_Range then
                    local currentTime = tick()
                    if currentTime - lastSpamTime >= spamInterval then
                        lastSpamTime = currentTime
                        task.spawn(function()
                            Parry(targetPosition)
                        end)
                    end
                end
            end
        end
        task.wait(0)
    end
end)

RunService.Stepped:Connect(function()
    if not aura_Enabled or not (workspace.Alive:FindFirstChild(local_player.Name) or training_mode) then
        task.spawn(resetAuraTable)
        return
    end

    local ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 10
    local self

    if training_mode then
        self = getTrainingBall()
    else
        self = Nurysium_Util.getBall()
    end

    if not self then
        task.spawn(resetAuraTable)
        return
    end

    task.spawn(function()
        self:GetAttributeChangedSignal("target"):Once(function()
            aura_table.canParry = true
        end)
    end)

    task.spawn(function()
        self:GetAttributeChangedSignal('from'):Once(function()
            aura_table.last_target = workspace.Alive:FindFirstChild(self:GetAttribute('from'))
        end)
    end)

    task.spawn(get_closest_entity, local_player.Character.PrimaryPart)

    local player_Position = local_player.Character.PrimaryPart.Position
    local ball_Position = self.Position
    local ball_Velocity = self.AssemblyLinearVelocity

    if self:FindFirstChild("zoomies") then
        ball_Velocity = self.zoomies.VectorVelocity
    end

    local ball_Direction = (local_player.Character.PrimaryPart.Position - ball_Position).Unit
    local ball_Distance = (local_player.Character.PrimaryPart.Position - ball_Position).Magnitude
    local ball_Dot = ball_Direction:Dot(ball_Velocity.Unit)
    local ball_Speed = ball_Velocity.Magnitude

    if ball_Speed < 10 then
        task.spawn(resetAuraTable)
    end

    local player_Position = local_player.Character.PrimaryPart.Position
    local player_Velocity = local_player.Character.HumanoidRootPart.AssemblyLinearVelocity
    local player_isMoving = player_Velocity.Magnitude > 0

    local ball_speed_Limited = math.clamp(ball_Speed / 1000, 0, 0.1)
    local ball_predicted_Distance = (ball_Distance - ping / 15.5) - (ball_Speed / 3.5)
    local target_Position = closest_Entity.HumanoidRootPart.Position
    local target_Distance = local_player:DistanceFromCharacter(target_Position)
    local closest_target_Distance = local_player:DistanceFromCharacter(closest_Entity.HumanoidRootPart.Position)
    local target_distance_Limited = math.clamp(target_Distance / 10000, 0, 0.1)
    local target_Direction = (local_player.Character.PrimaryPart.Position - closest_Entity.HumanoidRootPart.Position).Unit
    local target_Velocity = closest_Entity.HumanoidRootPart.AssemblyLinearVelocity
    local target_isMoving = target_Velocity.Magnitude > 0
    local target_Dot = target_isMoving and math.max(target_Direction:Dot(target_Velocity.Unit), 0)

    local speedFactor = 3.25 - (ping / 150)
    local speedFactorPingBased = 5.5 - (ping / 100)
    aura_table.parry_Range = math.max(math.max(ping, 3.5) + ball_Speed / speedFactor, speedFactorPingBased)

    aura_table.spam_Range = math.clamp((math.max(ping / 8, 15) + ball_Speed / 5.5), 0, 60)

    pcall(function()
        if target_isMoving then
            aura_table.is_Spamming = aura_table.hit_Count > 1 or (target_Distance <= aura_table.spam_Range and ball_Distance < 10 and ball_Speed > 10) and ball_Velocity.Y > -50 and velocity_angle < 0.2
        else
            aura_table.is_Spamming = aura_table.hit_Count > 1 or (target_Distance <= aura_table.spam_Range and ball_Distance < 10 and ball_Speed > 10) and ball_Velocity.Y > -50 and velocity_angle < 0.2
        end
    end)

    local velocity_angle = math.abs(math.acos(ball_Direction:Dot(ball_Velocity.Unit)))

    if ball_Dot < -0.2 then
        aura_table.ball_Warping = tick()
    end

    task.spawn(function()
        if (tick() - aura_table.ball_Warping) >= 0.15 + target_distance_Limited - ball_speed_Limited or ball_Distance <= 10 then
            aura_table.is_ball_Warping = false
            return
        end

        if aura_table.last_target then
            if (ball_Position - aura_table.last_target.HumanoidRootPart.Position).Magnitude > 35.5 or target_Distance <= 12 then
                aura_table.is_ball_Warping = false
            end
        end

        aura_table.is_ball_Warping = true
    end)

    if ball_Velocity.Y < -150 and self:FindFirstChild("AeroDynamicSlash") then
        task.wait(0.1)
    end

    if self:GetAttribute('target') == local_player.Name and ball_Distance <= aura_table.parry_Range and not aura_table.is_ball_Warping and ball_Speed > 0 and ball_Dot > 0.1 and aura_table.canParry then
        if aura_table.canParry then
            task.spawn(Parry, target_Position)
            aura_table.hit_Count = aura_table.hit_Count + 1
            task.delay(0.55 + (ping / 100), function()
                aura_table.hit_Count = math.max(0, aura_table.hit_Count - 1)
            end)
            aura_table.hit_Time = tick()
            aura_table.canParry = false
        end
    end

    task.spawn(function()
        repeat
            RunService.PreRender:Wait()
        until (tick() - aura_table.hit_Time) >= 1
        aura_table.canParry = true
    end)
end)

function resetAuraTable()
    aura_table.hit_Time = tick() * 10
    aura_table.hit_Count = 0
    aura_table.is_ball_Warping = false
    aura_table.is_Spamming = false
    aura_table.can_parry = true
    aura_table.last_target = nil
end

initializate("nurysium_temp")
